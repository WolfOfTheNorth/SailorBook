// This file will be generated by flutter_rust_bridge
// For now, we'll create a placeholder to enable compilation

String greet(String name) {
  return 'Hello, $name! (Mock implementation)';
}

void initLogger() {
  print('Logger initialized (Mock implementation)');
}

// Placeholder functions for the native bridge
// These will be replaced by actual generated code

class VoiceCfg {
  final String id;
  final double rate;
  final double pitch;

  VoiceCfg({
    required this.id,
    required this.rate,
    required this.pitch,
  });
}

class BookMeta {
  final String id;
  final String title;
  final String author;
  final String? coverUrl;
  final String downloadUrl;
  final double fileSizeMb;

  BookMeta({
    required this.id,
    required this.title,
    required this.author,
    this.coverUrl,
    required this.downloadUrl,
    required this.fileSizeMb,
  });
}

class Chapter {
  final int id;
  final String title;
  final List<int> paragraphIds;

  Chapter({
    required this.id,
    required this.title,
    required this.paragraphIds,
  });
}

class Paragraph {
  final int id;
  final int chapterId;
  final String text;
  final int wordCount;

  Paragraph({
    required this.id,
    required this.chapterId,
    required this.text,
    required this.wordCount,
  });
}

class Position {
  final int chapterId;
  final int paragraphId;
  final int offsetMs;

  Position({
    required this.chapterId,
    required this.paragraphId,
    required this.offsetMs,
  });
}

class Manifest {
  final String bookId;
  final String title;
  final String author;
  final List<Chapter> chapters;
  final List<Paragraph> paragraphs;
  final Position? lastPosition;

  Manifest({
    required this.bookId,
    required this.title,
    required this.author,
    required this.chapters,
    required this.paragraphs,
    this.lastPosition,
  });
}

// Mock implementations of Rust functions
Future<Manifest> buildManifest(String epubPath) async {
  await Future.delayed(const Duration(milliseconds: 500));
  return Manifest(
    bookId: 'mock_book_1',
    title: 'Mock Book Title',
    author: 'Mock Author',
    chapters: [
      Chapter(id: 0, title: 'Chapter 1', paragraphIds: [0, 1, 2]),
      Chapter(id: 1, title: 'Chapter 2', paragraphIds: [3, 4, 5]),
    ],
    paragraphs: [
      Paragraph(id: 0, chapterId: 0, text: 'This is the first paragraph.', wordCount: 6),
      Paragraph(id: 1, chapterId: 0, text: 'This is the second paragraph.', wordCount: 6),
      Paragraph(id: 2, chapterId: 0, text: 'This is the third paragraph.', wordCount: 6),
      Paragraph(id: 3, chapterId: 1, text: 'This is the fourth paragraph.', wordCount: 6),
      Paragraph(id: 4, chapterId: 1, text: 'This is the fifth paragraph.', wordCount: 6),
      Paragraph(id: 5, chapterId: 1, text: 'This is the sixth paragraph.', wordCount: 6),
    ],
  );
}

Future<List<int>> synthesize(String paragraph, VoiceCfg cfg) async {
  await Future.delayed(const Duration(milliseconds: 200));
  // Return mock audio data (empty for now)
  return List.generate(1000, (index) => index % 256);
}

Future<List<List<int>>> prebuffer(List<String> paragraphs, VoiceCfg cfg, int n) async {
  await Future.delayed(const Duration(milliseconds: 500));
  return paragraphs.take(n).map((p) => List.generate(1000, (index) => index % 256)).toList();
}

String cacheKeyFor(String paragraph, VoiceCfg cfg) {
  return 'mock_key_${paragraph.hashCode}_${cfg.id}_${cfg.rate}_${cfg.pitch}';
}

Future<void> saveManifest(String manifestPath, Manifest manifest) async {
  await Future.delayed(const Duration(milliseconds: 100));
}

Future<Manifest?> loadManifest(String manifestPath) async {
  await Future.delayed(const Duration(milliseconds: 100));
  return null; // No manifest exists initially
}

Future<void> updateLastPosition(String manifestPath, Position position) async {
  await Future.delayed(const Duration(milliseconds: 100));
}

Future<Position?> getLastPosition(String manifestPath) async {
  await Future.delayed(const Duration(milliseconds: 100));
  return null;
}

Future<void> createAudioCache(String cacheDir, int maxMemoryItems) async {
  await Future.delayed(const Duration(milliseconds: 100));
}